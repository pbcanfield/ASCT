from neuron import h

import torch

from sbi import utils as utils
from sbi.inference.base import infer
from sbi.inference import SNPE, prepare_for_sbi, simulate_for_sbi
from sbi.utils.get_nn_models import posterior_nn
import numpy as np
import matplotlib.pyplot as plt
from torch._C import Graph

#The job of the optimizer is to take some summary statistics and return a set of parameters which 
#are generated by SBI.
class Optimizer():
    
    #This function initializes SBI and sets the summary_stats function and
    #The target summary stats.
    #Takes the target cell to optimize.
    #Takes a parameter range tuple which consists of the lower and upper parameter tensors.
    #Takes a summary_stat function which calculates the summary statistics for the optimizer.
    #Takes some target statistics to match.
    def __init__(self, cell, parameter_range, summary_funct, spike_adaptation_threshold=0.95, spike_height_threshold=0):
        #Set some parameters.
        self.__cell = cell
        # self.__lower = parameter_range[0]
        # self.__upper = parameter_range[1]
        self.__summary_funct = summary_funct
        self.__spike_adaptation_threshold = spike_adaptation_threshold
        self.__spike_height_threshold=spike_height_threshold
        #Set the default simulation parameters.
        self.set_simulation_params()
        
        self.__i_clamp = h.IClamp(cell.soma[0](0.5))

        self.__cell_optimization_params = None

        if parameter_range != None:
            lows = torch.tensor(parameter_range[0], dtype=float)
            highs = torch.tensor(parameter_range[1], dtype=float)
            self.__prior = utils.BoxUniform(low=lows, high=highs)
    

    def set_simulation_params(self, sim_run_time = 1500, delay = 400, inj_time = 500, i_inj = 0.2, v_init = -75):
        self.__sim_run_time = sim_run_time
        self.__delay = delay
        self.__inj_time = inj_time
        self.__i_inj = i_inj
        self.__v_init = v_init

    def set_simulation_optimization_params(self, param_list):
        self.__cell_optimization_params = param_list

    def get_simulation_optimization_params(self):
        return self.__cell_optimization_params

    def simulation_wrapper(self, *args, **kwargs):
        
        
        #Set simulation parameters.
        h.tstop = self.__sim_run_time
        h.v_init = self.__v_init
        
        #Set current clamp values.
        self.__i_clamp.dur = self.__inj_time
        self.__i_clamp.amp = self.__i_inj
        self.__i_clamp.delay = self.__delay

        #Set parameters based on the parameters list.
        if self.__cell_optimization_params != None:
            for sec in self.__cell.all:
                for index, key in enumerate(self.__cell_optimization_params):
                    setattr(sec, key, args[0][index]) 

        #Set cell parameters in all sections based on the kwargs.
        for sec in self.__cell.all:
            for key in kwargs:
                setattr(sec, key, kwargs[key]) 

        h.run()

        #Return the summary statistics based on this simulation run.
        return self.__summary_funct(sim_variables=self.get_simulation_time_varibles(), spike_adaptation_threshold=self.__spike_adaptation_threshold, spike_height_threshold=self.__spike_height_threshold)



    #Returns a tuple countaining simulation time variables.
    def get_simulation_time_varibles(self):
        return (self.__sim_run_time, self.__delay, self.__inj_time)

    
    def run_inference(self, num_simulations=1000, workers=8):
        self.__posterior = infer(self.simulation_wrapper, self.__prior, method='SNPE', num_simulations=num_simulations, num_workers=workers)

    def set_target_statistics(self, stats):
        self.__observed_stats = stats

    def graph_performance(self, sample_threshold=1000):
        samples = self.__posterior.sample((sample_threshold,), x=self.__observed_stats)
        fig, axes = utils.pairplot(samples,
                        fig_size=(5,5),
                        points_offdiag={'markersize': 6},
                        labels=self.__cell_optimization_params,
                        points_colors='r');
        plt.tight_layout()
        plt.show()


    def get_best_sample(self): 
        return self.__posterior.sample((1,), x=self.__observed_stats).numpy()[0]


    def get_samples(self, sample_threshold):
        return self.__posterior.sample((sample_threshold,), x=self.__observed_stats).numpy()
